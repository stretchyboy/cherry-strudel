<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cherry Strudel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .row {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        textarea {
            flex: 1;
            min-height: 200px;
            padding: 10px;
            font-family: monospace;
        }
        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>

    <script src="https://unpkg.com/@strudel/repl@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/abcjs@6.5.2/dist/abcjs-basic-min.js"></script>

    <script>
        // Valid instruments from Strudel
        const validInstruments = new Set([
            'brown', 'bytebeat', 'crackle', 'gm_accordion', 'gm_acoustic_bass',
            'gm_acoustic_guitar_nylon', 'gm_acoustic_guitar_steel', 'gm_agogo',
            'gm_alto_sax', 'gm_applause', 'gm_bagpipe', 'gm_bandoneon', 'gm_banjo',
            'gm_baritone_sax', 'gm_bassoon', 'gm_bird_tweet', 'gm_blown_bottle',
            'gm_brass_section', 'gm_breath_noise', 'gm_celesta', 'gm_cello',
            'gm_choir_aahs', 'gm_church_organ', 'gm_clarinet', 'gm_clavinet',
            'gm_contrabass', 'gm_distortion_guitar', 'gm_drawbar_organ', 'gm_dulcimer',
            'gm_electric_bass_finger', 'gm_electric_bass_pick', 'gm_electric_guitar_clean',
            'gm_electric_guitar_jazz', 'gm_electric_guitar_muted', 'gm_english_horn',
            'gm_epiano1', 'gm_epiano2', 'gm_fiddle', 'gm_flute', 'gm_french_horn',
            'gm_fretless_bass', 'gm_fx_atmosphere', 'gm_fx_brightness', 'gm_fx_crystal',
            'gm_fx_echoes', 'gm_fx_goblins', 'gm_fx_rain', 'gm_fx_sci_fi',
            'gm_fx_soundtrack', 'gm_glockenspiel', 'gm_guitar_fret_noise',
            'gm_guitar_harmonics', 'gm_gunshot', 'gm_harmonica', 'gm_harpsichord',
            'gm_helicopter', 'gm_kalimba', 'gm_koto', 'gm_lead_1_square',
            'gm_lead_2_sawtooth', 'gm_lead_3_calliope', 'gm_lead_4_chiff',
            'gm_lead_5_charang', 'gm_lead_6_voice', 'gm_lead_7_fifths',
            'gm_lead_8_bass_lead', 'gm_marimba', 'gm_melodic_tom', 'gm_music_box',
            'gm_muted_trumpet', 'gm_oboe', 'gm_ocarina', 'gm_orchestra_hit',
            'gm_orchestral_harp', 'gm_overdriven_guitar', 'gm_pad_bowed',
            'gm_pad_choir', 'gm_pad_halo', 'gm_pad_metallic', 'gm_pad_new_age',
            'gm_pad_poly', 'gm_pad_sweep', 'gm_pad_warm', 'gm_pan_flute',
            'gm_percussive_organ', 'gm_piano', 'gm_piccolo', 'gm_pizzicato_strings',
            'gm_recorder', 'gm_reed_organ', 'gm_reverse_cymbal', 'gm_rock_organ',
            'gm_seashore', 'gm_shakuhachi', 'gm_shamisen', 'gm_shanai', 'gm_sitar',
            'gm_slap_bass_1', 'gm_slap_bass_2', 'gm_soprano_sax', 'gm_steel_drums',
            'gm_string_ensemble_1', 'gm_string_ensemble_2', 'gm_synth_bass_1',
            'gm_synth_bass_2', 'gm_synth_brass_1', 'gm_synth_brass_2', 'gm_synth_choir',
            'gm_synth_drum', 'gm_synth_strings_1', 'gm_synth_strings_2', 'gm_taiko_drum',
            'gm_telephone', 'gm_tenor_sax', 'gm_timpani', 'gm_tinkle_bell',
            'gm_tremolo_strings', 'gm_trombone', 'gm_trumpet', 'gm_tuba',
            'gm_tubular_bells', 'gm_vibraphone', 'gm_viola', 'gm_violin',
            'gm_voice_oohs', 'gm_whistle', 'gm_woodblock', 'gm_xylophone', 'pink',
            'pulse', 'saw', 'sawtooth', 'sbd', 'sin', 'sine', 'sqr', 'square',
            'supersaw', 'tri', 'triangle', 'user', 'white', 'z_noise', 'z_sawtooth',
            'z_sine', 'z_square', 'z_tan', 'z_triangle', 'zzfx'
        ]);

        // Helper: convert MIDI number to mini-notation note name with octave (C4 = 60)
        // Returns lowercase letter form used by Strudel, e.g. 'c4', 'g#3'
        function midiToNoteName(midi) {
            if (midi === null || midi === undefined || Number.isNaN(Number(midi))) return null;
            const n = Number(midi);
            const names = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
            const name = names[(n % 12 + 12) % 12];
            const octave = Math.floor(n / 12) - 1; // MIDI 60 -> 4 => 'c4'
            return `${name}${octave}`;
        }

// Map letter -> semitone offset (C = 0)
const letterOffset = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };

// Convert a bare note letter + accidental to MIDI with a chosen octave
function noteLetterToMidi(letterChar, accidentalCount, octave) {
    const up = letterChar.toUpperCase();
    if (!letterOffset.hasOwnProperty(up)) return null;
    // Convert to MIDI: (octave + 1) * 12 + offset  matches midiToNoteName inverse
    const base = letterOffset[up] + (octave + 1) * 12;
    return base + accidentalCount;
}

// Parse a raw ABC token (like "^c'" or "G,2") to a MIDI number.
// Returns null if parsing fails. Respects ABC octave marks (',' and "'")
// and accidentals (^ sharp, _ flat). Uses undecorated-letter rule: uppercase->4, lowercase->5.
function parseABCTokenToMidi(raw) {
    if (!raw || typeof raw !== 'string') return null;
    // find accidental string (sequence of ^ or _), letter, octave marks
    const accMatch = raw.match(/^([_^]+)?/);
    const accidentalStr = accMatch ? accMatch[0] : '';
    const carets = (accidentalStr.match(/\^/g) || []).length;
    const flats = (accidentalStr.match(/_/g) || []).length;
    const accidentalCount = carets - flats;
    const letterMatch = raw.match(/[A-Ga-g]/);
    if (!letterMatch) return null;
    const letter = letterMatch[0];
    // octave marks after the letter: sequence of , or '
    const octaveMarksMatch = raw.slice(raw.indexOf(letter) + 1).match(/^([,']*)/);
    const octaveMarks = octaveMarksMatch ? octaveMarksMatch[0] : '';
    // base octave per your rule: uppercase -> 4, lowercase -> 5
    let octave = (letter === letter.toLowerCase()) ? 5 : 4;
    for (const ch of octaveMarks) {
        if (ch === ',') octave--;
        else if (ch === "'") octave++;
    }
    return noteLetterToMidi(letter, accidentalCount, octave);
}

// Convert an array of rhythmic durations (floats) to small proportional integers.
// Strategy:
// 1. Use the smallest non-zero duration in the bar as the unit (quantum).
// 2. Convert each duration to an integer count of that unit (rounded).
// 3. Reduce the vector by their GCD so numbers stay small and editable.
// 4. If the resulting sum is very small, scale up to make a sensible bar (target sum 4).
function rhythmToIntegers(rhythm, targetSum) {
    const eps = 1e-9;
    if (!Array.isArray(rhythm) || rhythm.length === 0) return [];
    // find smallest non-zero duration
    const nonZero = rhythm.filter(r => (r || 0) > eps);
    if (nonZero.length === 0) return rhythm.map(_ => 1);
    const minDur = Math.min(...nonZero);

    // convert to integer multiples of minDur
    let ints = rhythm.map(r => {
        if (!r || r <= eps) return 0;
        return Math.max(1, Math.round(r / minDur));
    });

    // gcd helper
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    // reduce by gcd (ignore zeros when computing gcd)
    const positive = ints.filter(v => v > 0);
    let g = positive.length ? positive.reduce((a, b) => gcd(a, b)) : 1;
    if (!g || g < 1) g = 1;
    if (g > 1) ints = ints.map(v => Math.floor(v / g));

    // ensure we don't return all-zero (replace zeros with 1)
    ints = ints.map(v => v === 0 ? 1 : v);

    // If a targetSum (beats-per-bar in L-units) is provided, scale proportions
    if (typeof targetSum === 'number' && targetSum > 0) {
        let sum = ints.reduce((s, v) => s + v, 0);
        if (sum !== targetSum) {
            // scale proportionally to targetSum
            let scaled = ints.map(v => Math.max(1, Math.round((v * targetSum) / sum)));
            // adjust to exact target by incrementing/decrementing
            let s2 = scaled.reduce((s, v) => s + v, 0);
            let i = 0;
            while (s2 !== targetSum && scaled.length > 0 && i < 1000) {
                if (s2 > targetSum) {
                    // try to decrement the largest element > 1
                    let idx = scaled.reduce((bestIdx, val, idx) => (val > (scaled[bestIdx] || 0) ? idx : bestIdx), 0);
                    if (scaled[idx] > 1) { scaled[idx]--; s2--; }
                    else break;
                } else {
                    // increment the smallest element
                    let idx = scaled.reduce((bestIdx, val, idx) => (val < (scaled[bestIdx] || Infinity) ? idx : bestIdx), 0);
                    scaled[idx]++; s2++;
                }
                i++;
            }
            ints = scaled;
        }
    }

    return ints;
}

function abcToStrudel(abcText) {
    try {
        // Build list of bar character indices from the raw ABC
        const barIndices = [-1];
        for (let i = 0; i < abcText.length; i++) {
            if (abcText[i] === '|') barIndices.push(i);
        }
        barIndices.push(abcText.length);
        const numBars = Math.max(1, barIndices.length - 1);

        // Parse using abcjs
        ABCJS.renderAbc("paper", abcText);
        const tune = ABCJS.parseOnly(abcText);
        if (!tune || !tune[0]) return "// Failed to parse ABC notation";
        const tuneData = tune[0];

        console.debug('abcToStrudel: Parsed tune data=', tuneData);

        // instrument (fall back to gm_piano)
        let instrument = 'gm_piano';
        if (tuneData.metaText && tuneData.metaText.I) {
            const instrumentName = String(tuneData.metaText.I[0]).toLowerCase();
            if (validInstruments.has(instrumentName)) instrument = instrumentName;
        }

        // Determine beats-per-bar from ABC header (M: and L:). Default to 4
        let beatsPerBar = 4;
        try {
            const mMatch = abcText.match(/M:\s*([0-9]+)\/([0-9]+)/i);
            const lMatch = abcText.match(/L:\s*([0-9]+)\/([0-9]+)/i);
            if (mMatch && lMatch) {
                const mNum = Number(mMatch[1]);
                const mDen = Number(mMatch[2]);
                const lNum = Number(lMatch[1]);
                const lDen = Number(lMatch[2]);
                // number of L-units per bar = (M_num / M_den) / (L_num / L_den) = (M_num * L_den) / (M_den * L_num)
                const raw = (mNum * lDen) / (mDen * lNum);
                if (Number.isFinite(raw) && raw > 0) beatsPerBar = raw;
            } else if (mMatch) {
                // fallback: use numerator if L is missing
                beatsPerBar = Number(mMatch[1]) || beatsPerBar;
            }
        } catch (e) {
            // ignore parse errors and keep default
        }

        // Prepare empty bars (preserve order)
        const bars = [];
        for (let i = 0; i < numBars; i++) bars.push({ notes: [], rhythm: [], raws: [] });

        // Walk parsed elements and place each note/rest into the bar determined by its startChar
        for (const line of tuneData.lines || []) {
            if (!line.staff || !line.staff[0]) continue;
            for (const voice of line.staff[0].voices || []) {
                for (const el of voice) {
                    // Determine bar index by el.startChar (fallback to first bar)
                    let barIdx = 0;
                    if (typeof el.startChar === 'number' && el.startChar >= 0) {
                        for (let i = 0; i < numBars; i++) {
                            if (el.startChar > barIndices[i] && el.startChar <= barIndices[i + 1]) {
                                barIdx = i;
                                break;
                            }
                        }
                    }

                    // Rhythm: el.duration is in beats relative to L:; fallback to 1
                    const dur = (el.duration !== undefined && el.duration !== null) ? el.duration : 1;

                    // Get raw ABC token (if available) — compute early because we use it for rests
                    let raw = null;
                    if (typeof el.startChar === 'number' && typeof el.endChar === 'number' && el.startChar >= 0 && el.endChar >= el.startChar) {
                        raw = abcText.slice(el.startChar, el.endChar + 1);
                    }

                    if (el.rest) {
                        bars[barIdx].notes.push('~');
                        bars[barIdx].rhythm.push(dur);
                        bars[barIdx].raws.push(raw || '');
                        continue;
                    }

                    // If abc token had no octave marks we will map undecorated letters to C4/c5 per capitalization.
                    let finalNoteName = null;

                    // Try parsing the raw ABC token first (covers cases where abcjs
                    // didn't populate pitches). This handles accidentals and octave marks.
                    if (raw) {
                        const midiFromRaw = parseABCTokenToMidi(raw);
                        if (midiFromRaw !== null) finalNoteName = midiToNoteName(midiFromRaw);
                    }

                    // Otherwise fall back to abcjs pitch info
                    if (finalNoteName === null) {
                        if (el.pitches && el.pitches.length > 0) {
                            const p = el.pitches[0];
                            const midi = (p && (p.midi !== undefined)) ? p.midi : (p && p.pitch !== undefined ? p.pitch : null);
                            finalNoteName = midiToNoteName(midi);
                        } else if (el.pitch !== undefined) {
                            finalNoteName = midiToNoteName(el.pitch);
                        }
                    }

                    if (finalNoteName !== null) {
                        bars[barIdx].notes.push(finalNoteName);
                    } else {
                        bars[barIdx].notes.push('~');
                    }
                    bars[barIdx].rhythm.push(dur);
                    bars[barIdx].raws.push(raw || '');
                }
            }
        }

        // If some bars are empty, treat them as a single rest
        for (const b of bars) {
            if (b.notes.length === 0) {
                b.notes.push('~');
                b.rhythm.push(1);
                b.raws.push('');
            }
        }

        // Merge trailing implicit rests (where the raw token wasn't an explicit 'z')
        // into the previous note's duration so long notes aren't split as note+rest.
        for (const b of bars) {
            if (b.notes.length >= 2) {
                const lastIdx = b.notes.length - 1;
                if (b.notes[lastIdx] === '~') {
                    const raw = (b.raws[lastIdx] || '').trim();
                    // if raw does NOT contain an explicit 'z' rest, treat this '~' as implicit filler
                    if (raw.indexOf('z') === -1) {
                        // merge into previous
                        b.rhythm[lastIdx - 1] = (b.rhythm[lastIdx - 1] || 0) + (b.rhythm[lastIdx] || 0);
                        b.notes.splice(lastIdx, 1);
                        b.rhythm.splice(lastIdx, 1);
                        b.raws.splice(lastIdx, 1);
                    }
                }
            }
        }

        // Debug: print parsed bars (notes, raw durations, raw tokens)
        try {
            for (let i = 0; i < bars.length; i++) {
                const b = bars[i];
                // avoid overly verbose output but show key arrays
                console.debug(`abcToStrudel: bar[${i}] notes=`, b.notes, ' rhythm=', b.rhythm, ' raws=', b.raws);
            }
        } catch (e) {
            // ignore debug failures in older consoles
        }

        // Deduplicate identical bars and assign names
        const barMap = new Map();
        const uniqueBars = [];
        function keyForBar(b) {
            return b.notes.join(',') + '|' + b.rhythm.join(',');
        }

        for (const b of bars) {
            const k = keyForBar(b);
            if (!barMap.has(k)) {
                const id = `bar${uniqueBars.length}`;
                const entry = { id, notes: b.notes, rhythm: b.rhythm };
                barMap.set(k, entry);
                uniqueBars.push(entry);
            }
        }

        // Generate Strudel code (use const for bar defs; struct() uses durations)
        let code = `setcpm(15)\n\n`;
        for (const ub of uniqueBars) {
            const noteStr = ub.notes.join(' ');
            // compute integer struct values targeting beatsPerBar (rounded)
            const target = Math.max(1, Math.round(beatsPerBar));
            const ints = rhythmToIntegers(ub.rhythm, target);
            const rhythmStr = ints.join(' ');
            console.debug(`abcToStrudel: bar def ${ub.id} ints=`, ints, ' target=', target, ' rawRhythm=', ub.rhythm);
            // decide whether to emit named mini-notation (note) or numeric MIDI (n)
            const usesNamed = ub.notes.some(t => /[a-gA-G#~]/.test(t));
            const func = usesNamed ? 'note' : 'n';
            code += `const ${ub.id} = ${func}("${noteStr}").struct("${rhythmStr}");\n`;
        }

        // Build sequence referencing unique bar ids in order (deduped by name)
        const seq = bars.map(b => barMap.get(keyForBar(b)).id).join(', ');
        code += `\ncat(${seq}).s("${instrument}");\n`;

        return code;
    } catch (err) {
        console.error('Error in abcToStrudel:', err);
        return `// Error parsing ABC notation: ${err && err.message ? err.message : String(err)}`;
    }
}
// Handle convert button click
        document.addEventListener('DOMContentLoaded', function() {
            const convertBtn = document.getElementById('convert');
            const abcTextarea = document.getElementById('abc');
            
            if (convertBtn) {
                convertBtn.addEventListener('click', function() {
                    const abcText = abcTextarea.value;
                    const strudelCode = abcToStrudel(abcText);
                    
                    // Find the strudel-editor element and update it
                    const editor = document.querySelector('strudel-editor');
                    if (editor) {
                        editor.setAttribute('code', strudelCode);
                        // Trigger re-evaluation if the editor supports it
                        if (editor.requestUpdate) {
                            editor.requestUpdate();
                        }
                    }
                });
            }
        });
    </script>

    <h1>ABC → Strudel</h1>
    <p>Paste a monophonic ABC melody (one voice). Each bar becomes one Strudel cycle.</p>

    <div class="row">
        <textarea id="abc">
% Generated more or less automatically by swtoabc by Erich Rickheit KSC
X:1
T:Jingle Bells
M:4/4
L:1/4
K:C
 G/2G/2| G e d c| G3 G/2G/2| G e d c| A3 z/2 A/2| B f e d| B3 z/2 B/2|\
 g g f d| e3 G/2G/2| G e d c| G3 G/2G/2| G e d c| A3 z/2 A/2| B f e d|\
 g g g3/2 g/2| a g f d| c3 g| e e e2| e e e2| e g c3/2 d/2| e3 z| f f f3/2 f/2|\
 f e e e/2e/2| e d d e| d2 g2| e e e2| e e e2| e g c3/2 d/2| e3 z|\
 f f f3/2 f/2| f e e e/2e/2| g g f d| c3||
        </textarea>
        <button id="convert">Convert to Strudel</button>
    </div>

    <strudel-editor>
    </strudel-editor>
    <div id="paper"></div>
</body>
</html>